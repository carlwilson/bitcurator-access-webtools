#!/usr/bin/python
# coding=UTF-8
#
# BitCurator Access Webtools (Disk Image Access for the Web)
# Copyright (C) 2014
# All rights reserved.
#
# This code is distributed under the terms of the GNU General Public
# License, Version 3. See the text file "COPYING" for further details
# about the terms of this license.
#
# This file contains the user login routines for BitCurator Access webtools.
# Ref: http://code.tutsplus.com/tutorials/intro-to-flask-signing-in-and-out--net-29982
#
import logging

from flask import Flask, render_template, url_for, Response, current_app, redirect, session, request
from flask.ext.sqlalchemy import SQLAlchemy
from flask.ext.login import LoginManager, UserMixin
from werkzeug import generate_password_hash, check_password_hash
from rauth import OAuth1Service, OAuth2Service
from bcaw import app
from flask.ext.login import LoginManager, UserMixin, login_user, logout_user,\
    current_user


# Set up logging location for anyone importing these utils
logging.basicConfig(filename='/var/log/bcaw.log', level=logging.DEBUG)

#app = Flask(__name__)
#bcadb = SQLAlchemy(app)
 
bcadb = SQLAlchemy()
lm = LoginManager(app)
lm.login_view = 'localhost:8080'
###from runserver import bcadb

class User(UserMixin, bcadb.Model):
    __tablename__ = 'users'
    id = bcadb.Column(bcadb.Integer, primary_key=True)
    social_id = bcadb.Column(bcadb.String(64), nullable=False, unique=True)
    nickname = bcadb.Column(bcadb.String(64), nullable=False)
    email = bcadb.Column(bcadb.String(64), nullable=True)

# A call to login_user() invokes the routine load_user with the giveb ID.
@lm.user_loader
def load_user(id):
    # print "D:Load_user: ID: ", id
    return User.query.get(int(id))

class OAuthSignIn(object):
    providers = None

    def __init__(self, provider_name):
        # print "D: OAuthSignIn: In Constructor of class OAuthSignIn for provider ", provider_name
        self.provider_name = provider_name
        credentials = current_app.config['OAUTH_CREDENTIALS'][provider_name]
        self.consumer_id = credentials['id']
        self.consumer_secret = credentials['secret']

    def authorize(self):
        pass

    def callback(self):
        pass

    def get_callback_url(self):
        # print "D: Class:OAuthSignIn: get_callback_url: provider: ", self.provider_name
        '''
        FIXME: The following is supposed to return
        "http://localhost:8080/callback/<provider>/"
        Till it is fixed, it is hardcoded to return Facebook url.
        return url_for('oauth_callback', provider=self.provider_name,
                       _external=True)
        '''
        return "http://localhost:8080/callback/facebook/"

    @classmethod
    def get_provider(self, provider_name):
        if self.providers is None:
            self.providers = {}
            for provider_class in self.__subclasses__():
                provider = provider_class()
                self.providers[provider.provider_name] = provider
        return self.providers[provider_name]

class FacebookSignIn(OAuthSignIn):
    def __init__(self):
        super(FacebookSignIn, self).__init__('facebook')
        # print "D: constructor for clsas: Facebook SignIn: Client ID: {}, secret: {} ".format(self.consumer_id, self.consumer_secret) 
        self.service = OAuth2Service(
            name='facebook',
            client_id=self.consumer_id,
            client_secret=self.consumer_secret,
            authorize_url='https://graph.facebook.com/oauth/authorize',
            access_token_url='https://graph.facebook.com/oauth/access_token',
            base_url='https://graph.facebook.com/'
        )

    def authorize(self):
        ''' For OAuth 2 providers like Facebook the implementation simply issues a
            redirect to a URL generated by rauth's service object. Setting
            'scope' to 'email' indicates that we are asking Facebook to provide
            the user's email. The response_type=code argument tells the OAuth
            provider that the application is a web application. The redirect_uri
            argument is set to the application route that the provider needs to
            invoke after it completes the authentication.
        '''
        redirect_uri = self.get_callback_url()
        # print "D: FacebookSignIn: authoirizing: redirect uri: ", redirect_uri
        return redirect(self.service.get_authorize_url(
            scope='email',
            response_type='code',
            redirect_uri=redirect_uri)
        )

    def callback(self):
        if 'code' not in request.args:
            return None, None, None
        oauth_session = self.service.get_auth_session(
            data={'code': request.args['code'],
                  'grant_type': 'authorization_code',
                  'redirect_uri': self.get_callback_url()}
        )
        me = oauth_session.get('me?fields=id,email').json()
        return (
            'facebook$' + me['id'],
            me.get('email').split('@')[0],  # Facebook does not provide
                                            # username, so the email's user
                                            # is used instead
            me.get('email')
        )

# NOTE: Twittern routines not tested yet
class TwitterSignIn(OAuthSignIn):
    def __init__(self):
        super(TwitterSignIn, self).__init__('twitter')
        self.service = OAuth1Service(
            name='twitter',
            consumer_key=self.consumer_id,
            consumer_secret=self.consumer_secret,
            request_token_url='https://api.twitter.com/oauth/request_token',
            authorize_url='https://api.twitter.com/oauth/authorize',
            access_token_url='https://api.twitter.com/oauth/access_token',
            base_url='https://api.twitter.com/1.1/'
        )

    def authorize(self):
        request_token = self.service.get_request_token(
            params={'oauth_callback': self.get_callback_url()}
        )
        session['request_token'] = request_token
        return redirect(self.service.get_authorize_url(request_token[0]))

    def callback(self):
        request_token = session.pop('request_token')
        if 'oauth_verifier' not in request.args:
            return None, None, None
        oauth_session = self.service.get_auth_session(
            request_token[0],
            request_token[1],
            data={'oauth_verifier': request.args['oauth_verifier']}
        )
        me = oauth_session.get('account/verify_credentials.json').json()
        social_id = 'twitter$' + str(me.get('id'))
        username = me.get('screen_name')
        return social_id, username, None   # Twitter does not provide email

 
# The older log-in/log-out method provided used a locally maintained user db table.
# It is commented out or renamved to xxx_old for now.
class User_old(bcadb.Model):
  __tablename__ = 'users_old'
  uid = bcadb.Column(bcadb.Integer, primary_key = True)
  firstname = bcadb.Column(bcadb.String(100))
  lastname = bcadb.Column(bcadb.String(100))
  email = bcadb.Column(bcadb.String(120), unique=True)
  #pwdhash = bcadb.Column(bcadb.String(54))
  pwdhash = bcadb.Column(bcadb.String(200))
   
  def __init__(self, firstname, lastname, email, password):
    self.firstname = firstname.title()
    self.lastname = lastname.title()
    self.email = email.lower()
    self.set_password(password)
     
  def set_password(self, password):
    self.pwdhash = generate_password_hash(password)
   
  def check_password(self, password):
    return check_password_hash(self.pwdhash, password)

def dbinit(): 
   logging.debug('>>> Creating tables ')
   # print(">>> Creating tables ")
   #bcadb.drop_all()
   #bcadb.create_all()
